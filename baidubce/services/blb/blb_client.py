# Copyright (c) 2014 Baidu.com, Inc. All Rights Reserved
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions
# and limitations under the License.

"""
This module provides a client class for BLB.
"""

import copy
import json
import logging
import uuid

from baidubce import bce_base_client
from baidubce.auth import bce_v1_signer
from baidubce.http import bce_http_client
from baidubce.http import handler
from baidubce.http import http_methods

from baidubce.utils import required

_logger = logging.getLogger(__name__)


class BlbClient(bce_base_client.BceBaseClient):
    """
    BLB base sdk client
    """
    prefix = '/v1'

    def __init__(self, config=None):
        bce_base_client.BceBaseClient.__init__(self, config)

    def _merge_config(self, config=None):
        """
        :param config:
        :type config: baidubce.BceClientConfiguration
        :return:
        """
        if config is None:
            return self.config
        else:
            new_config = copy.copy(self.config)
            new_config.merge_non_none_values(config)
            return new_config

    def _send_request(self, http_method, path,
                      body=None, headers=None, params=None,
                      config=None, body_parser=None):
        config = self._merge_config(config)
        if body_parser is None:
            body_parser = handler.parse_json
        if headers is None:
            headers = {'Accept': '*/*',
                       'Content-Type': 'application/json;charset=utf-8'}
        return bce_http_client.send_request(
            config, bce_v1_signer.sign, [handler.parse_error, body_parser],
            http_method, BlbClient.prefix + path, body, headers, params)

    def create_loadbalancer(self, name=None, desc=None, vpc_id=None,
                            subnet_id=None, client_token=None, config=None):
        """
        Create a LoadBalancer with the specified options.

        :param name:
                the name of LoadBalancer to create
        :type name: string

        :param desc:
                The description of LoadBalancer
        :type desc: string

        :param vpc_id:
                id of vpc which the LoadBalancer belong to
        :type vpc_id: string

        :param subnet_id:
                id of subnet which the LoadBalancer belong to
        :type subnet_id: string

        :param client_token:
            If the clientToken is not specified by the user, a random String
            generated by default algorithm will be used.
        :type client_token: string

         :param config:
        :type config: baidubce.BceClientConfiguration

        :return:
        :rtype baidubce.bce_response.BceResponse
        """
        path = '/blb'
        params = {}

        if client_token is None:
            params['clientToken'] = generate_client_token()
        else:
            params['clientToken'] = client_token

        body = {}
        if name is not None:
            body['name'] = name
        if desc is not None:
            body['desc'] = desc
        if vpc_id is not None:
            body['vpcId'] = vpc_id
        if subnet_id is not None:
            body['subnetId'] = subnet_id

        return self._send_request(http_methods.POST, path,
                                  body=json.dumps(body), params=params,
                                  config=config)

    def describe_loadbalancer(self, address=None, name=None, blb_id=None,
                              bcc_id=None, marker=None, max_keys=None,
                              config=None):
        """
        Return a list of LoadBalancers

        :param address:
            Intranet service address in dotted decimal notation
        :type address: string

        :param name:
            name of LoadBalancer to describe
        :type name: string

        :param blb_id:
            id of LoadBalancer to describe
        :type blb_id: string

        :param bcc_id:
            bcc which bind the LoadBalancers
        :type bcc_id: string

        :param marker:
            The optional parameter marker specified in the original
            request to specify where in the results to begin listing.
            Together with the marker, specifies the list result
            which listing should begin.
            If the marker is not specified, the list result will
            listing from the first one.
        :type marker: string

        :param max_keys
        The optional parameter to specifies the max number of list
        result to return.
            The default value is 1000.
        :type max_keys: int

        :param config:
        :type config: baidubce.BceClientConfiguration

        :return:
        :rtype baidubce.bce_response.BceResponse
        """
        path = '/blb'
        params = {}

        if address is not None:
            params['address'] = address
        if name is not None:
            params['name'] = name
        if blb_id is not None:
            params['blbId'] = blb_id
        if bcc_id is not None:
            params['bccId'] = bcc_id
        if marker is not None:
            params['marker'] = marker
        if max_keys is not None:
            params['maxKeys'] = max_keys

        return self._send_request(http_methods.GET, path,
                                  params=params, config=config)

    @required(blbId=(str, unicode))
    def update_loadbalancer(self, blb_id, name=None, desc=None,
                            client_token=None, config=None):
        """
        Modify the special attribute to new value of the LoadBalancer
        owned by the user.

        :param name:
                name of LoadBalancer to describe
        :type name: string

        :param blb_id:
                id of LoadBalancer to describe
        :type blb_id: string

        :param desc:
                The description of LoadBalancer
        :type desc: string

        :param client_token:
                If the clientToken is not specified by the user,
                a random String generated by default algorithm
                will be used.
        :type client_token: string

        :param config:
        :type config: baidubce.BceClientConfiguration

        :return:
        :rtype baidubce.bce_response.BceResponse
        """
        path = '/blb/%s' % blb_id
        params = {}

        if client_token is None:
            params['clientToken'] = generate_client_token()
        else:
            params['clientToken'] = client_token

        body = {}
        if name is not None:
            body['name'] = name

        if desc is not None:
            body['desc'] = desc

        return self._send_request(http_methods.PUT, path, json.dumps(body),
                                  params=params, config=config)

    @required(blb_id=(str, unicode))
    def delete_loadbalancer(self, blb_id, client_token=None, config=None):
        """
        delete the LoadBalancer owned by the user.

        :param blb_id:
                id of LoadBalancer to describe
        :type blb_id: string

        :param client_token:
                If the clientToken is not specified by the user,
                a random String generated by default algorithm
                will be used.
        :type client_token: string

        :param config:
        :type config: baidubce.BceClientConfiguration

        :return:
        :rtype baidubce.bce_response.BceResponse
        """
        path = '/blb/%s' % blb_id
        params = {}

        if client_token is None:
            params['clientToken'] = generate_client_token()
        else:
            params['clientToken'] = client_token
        return self._send_request(http_methods.DELETE, path,
                                  params=params, config=config)

    @required(blb_id=(str, unicode),
              listener_port=int,
              backend_port=int,
              scheduler=(str, unicode))
    def create_tcp_listener(self, blb_id, listener_port,
                            backend_port, scheduler,
                            health_check_timeout_in_second=None,
                            health_check_interval=None,
                            unhealthy_threshold=None,
                            healthy_threshold=None,
                            client_token=None, config=None):
        """
        Create a tcp listener rule with the specified options.

        :param blb_id:
            the id of blb which the listener work on
        :type blb_id: string

        :param listener_port:
            port to be linstened owned by listener
        :value 1-65535
        :type listener_port: int

        :param backend_port:
            port to be listened owned by Backend server
        :value 1-65535
        :type backend_port: int

        :param scheduler
            balancing algorithm
        :value 'RoundRobin' or 'LeastConnection' or 'Hash'
        :type scheduler: string

        :param health_check_timeout_in_second
            Health check timeout
        :value 1-60, default: 3, unit: seconds
        :type health_check_timeout_in_second: string

        :param health_check_interval
            Health check interval
        :value 1-10, default: 3, unit: seconds
        :type health_check_interval: string

        :param unhealthy_threshold
            Unhealthy threshold,
            how many consecutive health check failures,
            shielding the backend server
        :value 2-5, default: 3
        :type unhealthy_threshold: string

        :param healthy_threshold
            Health threshold,
            how many consecutive health checks are successful,
            then re-use the back-end server
        :value 2-5, default: 3
        :type healthy_threshold: string

        :param client_token:
            If the clientToken is not specified by the user, a random String
            generated by default algorithm will be used.
        :type client_token: string

         :param config:
        :type config: baidubce.BceClientConfiguration

        :return:
        :rtype baidubce.bce_response.BceResponse
        """
        path = '/blb/%s/TCPlistener' % blb_id
        params = {}

        if client_token is None:
            params['clientToken'] = generate_client_token()
        else:
            params['clientToken'] = client_token

        body = {
            'listenerPort': listener_port,
            'backendPort': backend_port,
            'scheduler': scheduler
        }

        if health_check_timeout_in_second is not None:
            body['healthCheckTimeoutInSecond'] = \
                health_check_timeout_in_second
        if health_check_interval is not None:
            body['healthCheckInterval'] = health_check_interval
        if unhealthy_threshold is not None:
            body['unhealthyThreshold'] = unhealthy_threshold
        if healthy_threshold is not None:
            body['healthyThreshold'] = healthy_threshold

        return self._send_request(http_methods.POST, path,
                                  body=json.dumps(body), params=params,
                                  config=config)

    @required(blb_id=(str, unicode),
              listener_port=int,
              backend_port=int,
              scheduler=(str, unicode),
              health_check_string=(str, unicode))
    def create_udp_listener(self, blb_id, listener_port, backend_port,
                            scheduler, health_check_string,
                            health_check_timeout_in_second=None,
                            health_check_interval=None,
                            unhealthy_threshold=None,
                            healthy_threshold=None,
                            client_token=None, config=None):
        """
        Create a tcp listener rule with the specified options.

        :param blb_id:
            the id of blb which the listener work on
        :type blb_id: string

        :param listener_port:
            port to be linstened owned by listener
        :value 1-65535
        :type listener_port: int

        :param backend_port:
            port to be listened owned by Backend server
        :value 1-65535
        :type backend_port: int

        :param scheduler
            balancing algorithm
        :value 'RoundRobin' or 'LeastConnection' or 'Hash'
        :type scheduler: string

        :param health_check_string
            The request string sent by the health,
            the backend server needs to respond after receiving it.
        :type health_check_string: string

        :param health_check_timeout_in_second
            Health check timeout
        :value 1-60, default: 3, unit: seconds
        :type health_check_timeout_in_second: string

        :param health_check_interval
            Health check interval
        :value 1-10, default: 3, unit: seconds
        :type health_check_interval: string

       :param unhealthy_threshold
            Unhealthy threshold,
            how many consecutive health check failures,
            shielding the backend server
        :value 2-5, default: 3
        :type unhealthy_threshold: string

        :param healthy_threshold
            Health threshold,
            how many consecutive health checks are successful,
            then re-use the back-end server
        :value 2-5, default: 3
        :type healthy_threshold: string

        :param client_token:
            If the clientToken is not specified by the user, a random String
            generated by default algorithm will be used.
        :type client_token: string

         :param config:
        :type config: baidubce.BceClientConfiguration

        :return:
        :rtype baidubce.bce_response.BceResponse
        """
        path = '/blb/%s/UDPlistener' % blb_id
        params = {}

        if client_token is None:
            params['clientToken'] = generate_client_token()
        else:
            params['clientToken'] = client_token

        body = {
            'listenerPort': listener_port,
            'backendPort': backend_port,
            'scheduler': scheduler,
            'healthCheckString': health_check_string
        }

        if health_check_timeout_in_second is not None:
            body['healthCheckTimeoutInSecond'] = \
                health_check_timeout_in_second
        if health_check_interval is not None:
            body['healthCheckInterval'] = health_check_interval
        if unhealthy_threshold is not None:
            body['unhealthyThreshold'] = unhealthy_threshold
        if healthy_threshold is not None:
            body['healthyThreshold'] = healthy_threshold

        return self._send_request(http_methods.POST, path,
                                  body=json.dumps(body), params=params,
                                  config=config)

    @required(blb_id=(str, unicode), listener_port=int,
              backend_port=int, scheduler=(str, unicode))
    def create_http_listener(self, blb_id, listener_port,
                             backend_port, scheduler,
                             keep_session=None, keep_session_type=None,
                             keep_session_duration=None,
                             keep_session_cookie_name=None,
                             x_forward_for=None,
                             health_check_type=None, health_check_port=None,
                             health_check_uri=None,
                             health_check_timeout_in_second=None,
                             health_check_interval=None,
                             unhealthy_threshold=None,
                             healthy_threshold=None,
                             health_check_normal_status=None,
                             server_timeout=None, redirect_port=None,
                             client_token=None, config=None):
        """
        Create a http listener rule with the specified options.
        :param blb_id:
            the id of blb which the listener work on
        :type blb_id: string

        :param listener_port:
            port to be linstened owned by listener
        :value 1-65535
        :type listener_port: int

        :param backend_port:
            port to be listened owned by Backend server
        :value 1-65535
        :type backend_port: int

        :param scheduler:
            balancing algorithm
        :value 'RoundRobin' or 'LeastConnection'
        :type scheduler: string

        :param keep_session:
            Whether to enable the session hold function,
            that is,the request sent by the same client will
            reach the same backend server
        :value true or false  default:false
        :type keep_session: bool

        :param keep_session_type:
            The cookie handling method maintained by the session,
            valid only if the session is held open
            :value 'insert' or 'rewrite'  default:insert
        :type keep_session_type: string

        :param keep_session_duration:
            The time the cookie is kept in session (in seconds),
            valid only if the session is held open
            :value 1-15552000  default:3600
        :type keep_session_duration: int

        :param keep_session_cookie_name:
            The session keeps the name of the cookie that needs to be
            overridden if and only if session persistence is enabled
            and keep_session_type="rewrite"
        :type keep_session_cookie_name: int

        :param x_forward_for:
            Whether to enable the real IP address of the client,
            the backend server can obtain the real address of the client
            through the X-Forwarded-For HTTP header.
        :value true or false, default: False
        :type x_forward_for: bool

        :param health_check_type:
            Health check protocol
        :value 'HTTP' or 'TCP'
        :type health_check_type: string

        :param health_check_port:
            Health check port, the default is the same as backend_port
        :type health_check_port: int

        :param health_check_uri:
            Health check URI, default /.
            Effective when the health check protocol is "HTTP"
        :type health_check_uri: string

        :param health_check_timeout_in_second:
            Health check timeout (unit: second)
            :value 1-60, default: 3
        :type health_check_timeout_in_second: int

        :param health_check_interval:
            Health check interval (unit: second)
            :value 1-10, default: 3
        :type health_check_interval: int

        :param unhealth_threshold:
            The unhealthy threshold, that is,
            how many consecutive health check failures,
            shields the backend server.
        :value 2-5, default: 3
        :type unhealth_threshold: int

        :param health_threshold:
            Health threshold, that is,
            how many consecutive health checks are successful,
            then re-use the back-end server
        value: 2-5, default: 3
        :type health_threshold: int

        :param health_check_normal_status:
            The HTTP status code when the health check is normal supports
            a combination of five types of status codes,
            such as "http_1xx|http_2xx",
            Effective when the health check protocol is "HTTP"
        :value default:http_2xx|http_3xx
        :type health_check_normal_status:string

        :param server_timeout:
            Backend server maximum timeout (unit: second)
        :value 1-3600, default: 30
        :type server_timeout:int

        :param redirect_port:
            Forward the request received by this listener to the
            HTTPS listener, which is specified by the HTTPS listener.
        :type redirect_port:int

        :param client_token:
            If the clientToken is not specified by the user,
            a random String generated by default algorithm will be used.
        :type client_token: string

        :param config:
        :type config: baidubce.BceClientConfiguration

        :return:
        :rtype baidubce.bce_response.BceResponse
        """
        path = '/blb/%s/HTTPlistener' % blb_id
        params = {}
        if client_token is None:
            params['clientToken'] = generate_client_token()
        else:
            params['clientToken'] = client_token
        body = {
            'listenerPort': listener_port,
            'backendPort': backend_port,
            'scheduler': scheduler}
        if keep_session is not None:
            body['keepSession'] = keep_session
        if keep_session_type is not None:
            body['keepSessionType'] = keep_session_type
        if keep_session_duration is not None:
            body['keepSessionDuration'] = keep_session_duration
        if keep_session_cookie_name is not None:
            body['keepSessionCookieName'] = keep_session_cookie_name
        if x_forward_for is not None:
            body['xForwardFor'] = x_forward_for
        if health_check_type is not None:
            body['healthCheckType'] = health_check_type
        if health_check_port is not None:
            body['healthCheckPort'] = health_check_port
        if health_check_uri is not None:
            body['healthCheckURI'] = health_check_uri
        if health_check_timeout_in_second is not None:
            body['healthCheckTimeoutInSecond'] = \
                health_check_timeout_in_second
        if health_check_interval is not None:
            body['healthCheckInterval'] = health_check_interval
        if unhealthy_threshold is not None:
            body['unhealthyThreshold'] = unhealthy_threshold
        if healthy_threshold is not None:
            body['healthyThreshold'] = healthy_threshold
        if health_check_normal_status is not None:
            body['healthCheckNormalStatus'] = health_check_normal_status
        if server_timeout is not None:
            body['serverTimeout'] = server_timeout
        if redirect_port is not None:
            body['redirectPort'] = redirect_port
        return self._send_request(http_methods.POST, path,
                                  body=json.dumps(body), params=params,
                                  config=config)

    @required(blb_id=(str, unicode), listener_port=int,
              backend_port=int, scheduler=(str, unicode), cert_ids=list)
    def create_https_listener(self, blb_id, listener_port, backend_port,
                              scheduler, cert_ids, keep_session=None,
                              keep_session_type=None,
                              keep_session_duration=None,
                              keep_session_cookie_name=None,
                              x_forward_for=None, health_check_type=None,
                              health_check_port=None, health_check_uri=None,
                              health_check_timeout_in_second=None,
                              health_check_interval=None,
                              unhealth_threshold=None, health_threshold=None,
                              health_check_normal_status=None,
                              server_timeout=None,
                              ie6_compatible=None, client_token=None,
                              config=None):
        """
        Create a https listener rule with the specified options.

        :param blb_id:
            The id of blb which the listener work on
        :type blb_id: string

        :param listener_port:
            port to be linstened owned by listener
        :value 1-65535
        :type listener_port: int

        :param backend_port:
            Port to be listened owned by Backend server
        :value 1-65535
        :type backend_port: int

        :param scheduler:
            balancing algorithm
        :value 'RoundRobin' or 'LeastConnection'
        :type scheduler: string

        :param cert_ids:
            The SSL certificate to be loaded by the listener.
            Currently HTTPS listeners can only bind one SSL certificate.
        :type cert_ids: List<String>

        :param keep_session:
            Whether to enable the session hold function,
            that is, the request sent by the same client will reach the
            same backend server
        :value true or false, default: false
        :type keep_session: bool

        :param keep_session_type:
            The cookie handling method maintained by the session,
            valid only if the session is held open
        :value 'insert' or 'rewrite', default:insert
        :type keep_session_type: string

        :param keep_session_duration:
            The time the cookie is kept in session (in seconds),
            valid only if the session is held open
        :value 1-15552000, default:3600
        :type keep_session_duration: int

        :param keep_session_cookie_name:
            The session keeps the name of the cookie that needs
            to be overridden if and only if session persistence
            is enabled and keep_session_type="rewrite"
        :type keep_session_cookie_name: int

        :param x_forward_for:
            Whether to enable the real IP address of the client,
            the backend server can obtain the real address of the client
            through the X-Forwarded-For HTTP header.
        :value true or false, default: flase
        :type x_forward_for: bool

        :param health_check_type:
            Health check protocol
        :value 'HTTP' or 'TCP'
        :type health_check_type: string

        :param health_check_port:
            Health check port, the default is the same as backend_port
        :type health_check_port: int

        :param health_check_uri:
            Health check URI, default /.
            Effective when the health check protocol is "HTTP"
        :type health_check_uri: string

        :param health_check_timeout_in_second:
            Health check timeout (unit: second)
            :value 1-60, default:3
        :type health_check_timeout_in_second: int

        :param health_check_interval:
            Health check interval (unit: second)
        :value 1-10, default: 3
        :type health_check_interval: int

        :param unhealth_threshold:
            The unhealthy threshold, that is, how many consecutive health
             check failures, shields the backend server.
        :value 2-5, default: 3
        :type unhealth_threshold: int

        :param health_threshold:
            Health threshold, that is, how many consecutive health checks
             are successful, then re-use the back-end server
        :value:2-5, default: 3
        :type health_threshold: int

        :param health_check_normal_status:
            The HTTP status code when the health check is normal
            supports a combination of five types of status codes,
            such as "http_1xx|http_2xx", Effective when the health check
            protocol is "HTTP"
        :value default: http_2xx|http_3xx
        :type health_check_normal_status: string

        :param server_timeout:
            Backend server maximum timeout (unit: second)
        :value 1-3600, default: 30
        :type server_timeout: int

        :param ie6_compatible:
            compatible with IE6 HTTPS request
            (the protocol format is earlier SSL3.0, the security is poor)
        :value true or false, default: true
        :type ie6_compatible: bool

        :param client_token:
            If the clientToken is not specified by the user,
            a random String generated by default algorithm will be used.
        :type client_token: string

        :param config:
        :type config: baidubce.BceClientConfiguration

        :return
        :rtype baidubce.bce_response.BceResponse
        """
        path = '/blb/%s/HTTPSlistener' % blb_id
        params = {}
        if client_token is None:
            params['clientToken'] = generate_client_token()
        else:
            params['clientToken'] = client_token
        body = {
            'listenerPort': listener_port, 'backendPort': backend_port,
            'scheduler': scheduler, 'certIds': cert_ids}
        if keep_session is not None:
            body['keepSession'] = keep_session
        if keep_session_type is not None:
            body['keepSessionType'] = keep_session_type
        if keep_session_duration is not None:
            body['keepSessionDuration'] = keep_session_duration
        if keep_session_cookie_name is not None:
            body['keepSessionCookieName'] = keep_session_cookie_name
        if x_forward_for is not None:
            body['xForwardFor'] = x_forward_for
        if health_check_type is not None:
            body['healthCheckType'] = health_check_type
        if health_check_port is not None:
            body['healthCheckPort'] = health_check_port
        if health_check_uri is not None:
            body['healthCheckURI'] = health_check_uri
        if health_check_timeout_in_second is not None:
            body['healthCheckTimeoutInSecond'] = \
                health_check_timeout_in_second
        if health_check_interval is not None:
            body['healthCheckInterval'] = health_check_interval
        if unhealth_threshold is not None:
            body['unhealthyThreshold'] = unhealth_threshold
        if health_threshold is not None:
            body['healthyThreshold'] = health_threshold
        if health_check_normal_status is not None:
            body['healthCheckNormalStatus'] = health_check_normal_status
        if server_timeout is not None:
            body['serverTimeout'] = server_timeout
        if ie6_compatible is not None:
            body['ie6Compatible'] = ie6_compatible
        return self._send_request(http_methods.POST, path,
                                  body=json.dumps(body),
                                  params=params, config=config)

    @required(blb_id=(str, unicode))
    def describe_tcp_listener(self, blb_id, listener_port=None,
                              marker=None, max_keys=None, config=None):
        """
        get a tcp listener identified by bibID

        :param blb_id
             the id of blb which the listener work on
        :type blb_id:string

        :param listener_port
             The listener port to query
        :type listener_port:int

        :param marker
            The optional parameter marker specified in the
            original request to specify
            where in the results to begin listing.
            Together with the marker, specifies the list result
            which listing should begin.
            If the marker is not specified, the list result will
            listing from the first one.
        :type marker: string

        :param max_keys
            The optional parameter to specifies the max number of
            list result to return.
            The default value is 1000.
        :type max_keys: int

        :param config:
        :type config: baidubce.BceClientConfiguration

        :return:
        :rtype baidubce.bce_response.BceResponse
        """
        path = '/blb/%s/TCPlistener' % blb_id
        params = {}

        if listener_port is not None:
            params['listenerPort'] = listener_port
        if marker is not None:
            params['marker'] = marker
        if max_keys is not None:
            params['maxKeys'] = max_keys

        return self._send_request(http_methods.GET, path,
                                  params=params, config=config)

    @required(blb_id=(str, unicode))
    def describe_udp_listener(self, blb_id, listener_port=None, marker=None,
                              max_keys=None, config=None):
        """
        get a udp listener identified by bibID

        :param blb_id
             the id of blb which the listener work on
        :type blb_id:string

        :param listener_port
             The listener port to query
        :type listener_port:int

        :param marker
            The optional parameter marker specified in the original
            request to specify where in the results to begin listing.
            Together with the marker, specifies the list result which
            listing should begin.
            If the marker is not specified, the list result will
            listing from the first one.
        :type marker: string

        :param max_keys
        The optional parameter to specifies the max number of
        list result to return.
            The default value is 1000.
        :type max_keys: int

        :param config:
        :type config: baidubce.BceClientConfiguration

        :return:
        :rtype baidubce.bce_response.BceResponse
        """
        path = '/blb/%s/UDPlistener' % blb_id
        params = {}

        if listener_port is not None:
            params['listenerPort'] = listener_port
        if marker is not None:
            params['marker'] = marker
        if max_keys is not None:
            params['maxKeys'] = max_keys

        return self._send_request(http_methods.GET, path,
                                  params=params, config=config)

    @required(blb_id=(str, unicode))
    def describe_http_listener(self, blb_id, listener_port=None,
                               marker=None, max_keys=None, config=None):
        """
        get a http listener identified by bibID

        :param blb_id
             the id of blb which the listener work on
        :type blb_id:string

        :param listener_port
             The listener port to query
        :type listener_port:int

        :param marker
            The optional parameter marker specified in the original
            request to specify where in the results to begin listing.
            Together with the marker, specifies the list result which
            listing should begin.
            If the marker is not specified, the list result will listing
            from the first one.
        :type marker: string

        :param max_keys
            The optional parameter to specifies the max number of list
            result to return.
            The default value is 1000.
        :type max_keys: int

        :param config:
        :type config: baidubce.BceClientConfiguration

        :return:
        :rtype baidubce.bce_response.BceResponse
        """
        path = '/blb/%s/HTTPlistener' % blb_id
        params = {}

        if listener_port is not None:
            params['listenerPort'] = listener_port
        if marker is not None:
            params['marker'] = marker
        if max_keys is not None:
            params['maxKeys'] = max_keys

        return self._send_request(http_methods.GET, path,
                                  params=params, config=config)

    @required(blb_id=(str, unicode))
    def describe_https_listener(self, blb_id, listener_port=None,
                                marker=None, max_keys=None, config=None):
        """
        get a https listener identified by bibID

        :param blb_id
             the id of blb which the listener work on
        :type blb_id:string

        :param listener_port
             The listener port to query
        :type listener_port:int

        :param marker
            The optional parameter marker specified in the original
            request to specify where in the results to begin listing.
            Together with the marker, specifies the list result which
            listing should begin.
            If the marker is not specified, the list result will listing
            from the first one.
        :type marker: string

        :param max_keys
            The optional parameter to specifies the max number of list
            result to return.
            The default value is 1000.
        :type max_keys: int

        :param config:
        :type config: baidubce.BceClientConfiguration

        :return:
        :rtype baidubce.bce_response.BceResponse
        """
        path = '/blb/%s/HTTPSlistener' % blb_id
        params = {}

        if listener_port is not None:
            params['listenerPort'] = listener_port
        if marker is not None:
            params['marker'] = marker
        if max_keys is not None:
            params['maxKeys'] = max_keys

        return self._send_request(http_methods.GET, path,
                                  params=params, config=config)

    @required(blb_id=(str, unicode),
              listener_port=int)
    def update_tcp_listener(self, blb_id, listener_port,
                            backend_port=None, scheduler=None,
                            health_check_timeout_in_second=None,
                            health_check_interval=None,
                            unhealth_threshold=None,
                            health_threshold=None,
                            client_token=None, config=None):
        """
        update a tcp listener rule with the specified options.

        :param blb_id:
            the id of blb which the listener work on
        :type blb_id:string

        :param listener_port:
             port to be linstened owned by listener
        :value 1-65535
        :type listener_port:int

        :param backend_port:
            port to be listened owned by Backend server
        :value 1-65535
        :type backend_port:int

        :param scheduler
            balancing algorithm
        :value 'RoundRobin'or'LeastConnection'or'Hash'
        :type scheduler:string

        :param health_check_timeout_in_second
            Health check timeout
        :value 1-60  default:3 unit:seconds
        :type health_check_timeout_in_second:string

        :param health_check_interval
            Health check interval
        :value 1-10 default:3 unit:seconds
        :type health_check_interval:string

        :param unhealth_threshold
            Unhealthy threshold,
             how many consecutive health check failures,
             shielding the backend server
        :value 2-5 default:3
        :type unhealth_threshold:string

        :param health_threshold
            Health threshold,
            how many consecutive health checks are successful,
            then re-use the back-end server
        :value 2-5 default:3
        :type health_threshold:string

        :param client_token:
            If the clientToken is not specified by the user, a random String
            generated by default algorithm will be used.
        :type client_token: string

         :param config:
        :type config: baidubce.BceClientConfiguration

        :return:
        :rtype baidubce.bce_response.BceResponse
        """
        path = '/blb/%s/TCPlistener' % blb_id
        params = {}

        params['listenerPort'] = listener_port

        if client_token is None:
            params['clientToken'] = generate_client_token()
        else:
            params['clientToken'] = client_token

        body = {}
        if backend_port is not None:
            body['backendPort'] = backend_port
        if scheduler is not None:
            body['scheduler'] = scheduler
        if health_check_timeout_in_second is not None:
            body['healthCheckTimeoutInSecond'] = \
                health_check_timeout_in_second
        if health_check_interval is not None:
            body['healthCheckInterval'] = health_check_interval
        if unhealth_threshold is not None:
            body['unhealthyThreshold'] = unhealth_threshold
        if health_threshold is not None:
            body['healthyThreshold'] = health_threshold

        return self._send_request(http_methods.PUT, path,
                                  body=json.dumps(body), params=params,
                                  config=config)

    @required(blb_id=(str, unicode),
              listener_port=int,
              backend_port=int,
              scheduler=(str, unicode),
              health_check_string=(str, unicode))
    def update_udp_listener(self, blb_id, listener_port, backend_port,
                            scheduler, health_check_string,
                            health_check_timeout_in_second=None,
                            health_check_interval=None,
                            unhealth_threshold=None,
                            health_threshold=None,
                            client_token=None, config=None):
        """
        update a udp listener rule with the specified options.

        :param blb_id:
                the id of blb which the listener work on
        :type blb_id:string

        :param listener_port:
                port to be linstened owned by listener
        :value 1-65535
        :type listener_port:int

        :param backend_port:
                port to be listened owned by Backend server
        :value 1-65535
        :type backend_port:int

        :param scheduler
              balancing algorithm
        :value 'RoundRobin'or'LeastConnection'or'Hash'
        :type scheduler:string

        :param health_check_string
              The request string sent by the health,
              the backend server needs to respond after receiving it,
              and supports standard escaping
        :type health_check_string:string

        :param health_check_timeout_in_second
                Health check timeout
        :value 1-60  default:3 unit:seconds
        :type health_check_timeout_in_second:string

        :param health_check_interval
                Health check interval
        :value 1-10 default:3 unit:seconds
        :type health_check_interval:string

        :param unhealth_threshold
                Unhealthy threshold,
                 how many consecutive health check failures,
                 shielding the backend server
        :value 2-5 default:3
        :type unhealth_threshold:string

        :param health_threshold
                Health threshold,
                how many consecutive health checks are successful,
                then re-use the back-end server
        :value 2-5 default:3
        :type health_threshold:string

        :param client_token:
            If the clientToken is not specified by the user, a random String
            generated by default algorithm will be used.
        :type client_token: string

         :param config:
        :type config: baidubce.BceClientConfiguration

        :return:
        :rtype baidubce.bce_response.BceResponse
        """
        path = '/blb/%s/UDPlistener' % blb_id
        params = {}

        params['listenerPort'] = listener_port

        if client_token is None:
            params['clientToken'] = generate_client_token()
        else:
            params['clientToken'] = client_token

        body = {
            'backendPort': backend_port,
            'scheduler': scheduler,
            'healthCheckString': health_check_string
        }

        if health_check_timeout_in_second is not None:
            body['healthCheckTimeoutInSecond'] = \
                health_check_timeout_in_second
        if health_check_interval is not None:
            body['healthCheckInterval'] = health_check_interval
        if unhealth_threshold is not None:
            body['unhealthyThreshold'] = unhealth_threshold
        if health_threshold is not None:
            body['healthyThreshold'] = health_threshold

        return self._send_request(http_methods.PUT, path,
                                  body=json.dumps(body),
                                  params=params, config=config)

    @required(blb_id=(str, unicode),
              listener_port=int)
    def update_http_listener(self, blb_id, listener_port, backend_port=None,
                             scheduler=None, keep_session=None,
                             keep_session_type=None,
                             keep_session_duration=None,
                             keep_session_cookie_name=None,
                             x_forward_for=None,
                             health_check_type=None, health_check_port=None,
                             health_check_uri=None,
                             health_check_timeout_in_second=None,
                             health_check_interval=None,
                             unhealth_threshold=None, health_threshold=None,
                             health_check_normal_status=None,
                             server_timeout=None,
                             redirect_port=None, client_token=None,
                             config=None):
        """
        update a http listener rule with the specified options.

        :param blb_id:
            The id of blb which the listener work on
        :type blb_id: string

        :param listener_port:
            Port to be linstened owned by listener
        :value 1-65535
        :type listener_port: int

        :param backend_port:
            port to be listened owned by Backend server
        :value 1-65535
        :type backend_port: int

        :param scheduler:
            Balancing algorithm
        :value 'RoundRobin' or 'LeastConnection' or 'Hash'
        :type scheduler: string

        :param keep_session:
            Whether to enable the session hold function, that is,
            the request sent by the same client will reach the
            same backend server
        :value true or false, default:false
        :type keep_session: bool

        :param keep_session_type:
            The cookie handling method maintained by the session,
            valid only if the session is held open
        :value 'insert' or 'rewrite', default:insert
        :type keep_session_type: string

        :param keep_session_duration:
            The time the cookie is kept in session (in seconds),
            valid only if the session is held open
        :value 1-15552000, default:3600
        :type keep_session_duration: int

        :param keep_session_cookie_name:
            The session keeps the name of the cookie that needs
            to be overridden,if and only if session persistence is
            enabled and keep_session_type="rewrite"
        :type keep_session_cookie_name: int

        :param x_forward_for:
            Whether to enable the real IP address of the client,
            the backend server can obtain the real address of the
            client through the X-Forwarded-For HTTP header.
        :value true or false, default: flase
        :type x_forward_for: bool

        :param health_check_type:
            Health check protocol
        :value 'HTTP' or 'TCP'
        :type health_check_type: string

        :param health_check_port:
            Health check port, the default is the same as backend_port
        :type health_check_port: int

        :param health_check_uri:
            Health check URI, default /.
            Effective when the health check protocol is "HTTP"
        :type health_check_uri: string

        :param health_check_timeout_in_second:
            Health check timeout (unit: second)
        :value 1-60, default: 3
        :type health_check_timeout_in_second: int

        :param health_check_interval:
            Health check interval (unit: second)
        :value 1-10, default: 3
        :type health_check_interval: int

        :param unhealth_threshold:
            The unhealthy threshold, that is, how many consecutive health
            check failures, shields the backend server.
        :value 2-5, default: 3
        :type unhealth_threshold: int

        :param health_threshold:
            Health threshold, that is, how many consecutive health checks
            are successful, then re-use the back-end server
        :value:2-5, default: 3
        :type health_threshold: int

        :param health_check_normal_status:
            The HTTP status code when the health check is normal supports
            a combination of five types of status codes,
            such as "http_1xx|http_2xx", Effective when the health check
            protocol is "HTTP"
        :value default: http_2xx|http_3xx
        :type health_check_normal_status: string

        :param server_timeout:
            Backend server maximum timeout (unit: second)
        :value 1-3600, default: 30
        :type server_timeout: int

        :param redirect_port:
            Forward the request received by this listener to the HTTPS
            listener, which is specified by the HTTPS listener.
        :type redirect_port: int

        :param client_token:
            If the clientToken is not specified by the user,
            a random String generated by default algorithm will be used.
        :type client_token: string

        :param config:
        :type config: baidubce.BceClientConfiguration

        :return:
        :rtype baidubce.bce_response.BceResponse
        """
        path = '/blb/%s/HTTPlistener' % blb_id
        params = {}
        params['listenerPort'] = listener_port
        if client_token is None:
            params['clientToken'] = generate_client_token()
        else:
            params['clientToken'] = client_token
        body = {}
        if backend_port is not None:
            body['backendPort'] = backend_port
        if scheduler is not None:
            body['scheduler'] = scheduler
        if keep_session is not None:
            body['keepSession'] = keep_session
        if keep_session_type is not None:
            body['keepSessionType'] = keep_session_type
        if keep_session_duration is not None:
            body['keepSessionDuration'] = keep_session_duration
        if keep_session_cookie_name is not None:
            body['keepSessionCookieName'] = keep_session_cookie_name
        if x_forward_for is not None:
            body['xForwardFor'] = x_forward_for
        if health_check_type is not None:
            body['healthCheckType'] = health_check_type
        if health_check_port is not None:
            body['healthCheckPort'] = health_check_port
        if health_check_uri is not None:
            body['healthCheckURI'] = health_check_uri
        if health_check_timeout_in_second is not None:
            body['healthCheckTimeoutInSecond'] = \
                health_check_timeout_in_second
        if health_check_interval is not None:
            body['healthCheckInterval'] = health_check_interval
        if unhealth_threshold is not None:
            body['unhealthyThreshold'] = unhealth_threshold
        if health_threshold is not None:
            body['healthyThreshold'] = health_threshold
        if health_check_normal_status is not None:
            body['healthCheckNormalStatus'] = health_check_normal_status
        if server_timeout is not None:
            body['serverTimeout'] = server_timeout
        if redirect_port is not None:
            body['redirectPort'] = redirect_port
        return self._send_request(http_methods.PUT, path,
                                  body=json.dumps(body),
                                  params=params, config=config)

    @required(blb_id=(str, unicode), listener_port=int)
    def update_https_listener(self, blb_id, listener_port,
                              backend_port=None,
                              scheduler=None, keep_session=None,
                              keep_session_type=None,
                              keep_session_duration=None,
                              keep_session_cookie_name=None,
                              x_forward_for=None, health_check_type=None,
                              health_check_port=None, health_check_uri=None,
                              health_check_timeout_in_second=None,
                              health_check_interval=None,
                              unhealth_threshold=None, health_threshold=None,
                              health_check_normal_status=None,
                              server_timeout=None,
                              cert_ids=None, ie6_compatible=None,
                              client_token=None, config=None):
        """
        Update a https listener rule with the specified options.

        :param blb_id:
            The id of blb which the listener work on
        :type blb_id: string

        :param listener_port:
            Port to be linstened owned by listener
        :value 1-65535
        :type listener_port: int

        :param backend_port:
            Port to be listened owned by Backend server
        :value 1-65535
        :type backend_port: int

        :param scheduler:
            Balancing algorithm
        :value 'RoundRobin' or 'LeastConnection' or 'Hash'
        :type scheduler: string

        :param keep_session:
            Whether to enable the session hold function, that is, the request
            sent by the same client will reach the same backend server
        :value true or false, default: false
        :type keep_session: bool

        :param keep_session_type:
            The cookie handling method maintained by the session,
            valid only if the session is held open
        :value 'insert' or 'rewrite', default: insert
        :type keep_session_type: string

        :param keep_session_duration:
            The time the cookie is kept in session (in seconds),
            valid only if the session is held open
        :value 1-15552000, default:3600
        :type keep_session_duration: int

        :param keep_session_cookie_name:
            The session keeps the name of the cookie that needs to be
            overridden,if and only if session persistence is enabled and
            keep_session_type="rewrite"
        :type keep_session_cookie_name: int

        :param x_forward_for:
            Whether to enable the real IP address of the client,
            the backend server can obtain the real address of the client
            through the X-Forwarded-For HTTP header.
        :value true or false, default: False
        :type x_forward_for: bool

        :param health_check_type:
            Health check protocol
        :value 'HTTP' or 'TCP'
        :type health_check_type: string

        :param health_check_port:
            Health check port, the default is the same as backend_port
        :type health_check_port: int

        :param health_check_uri:
            Health check URI, default /.
            Effective when the health check protocol is "HTTP"
        :type health_check_uri: string

        :param health_check_timeout_in_second:
            Health check timeout (unit: second)
        :value 1-60, default: 3
        :type health_check_timeout_in_second: int

        :param health_check_interval:
            Health check interval (unit: second)
        :value 1-10, default: 3
        :type health_check_interval: int

        :param unhealth_threshold:
            The unhealthy threshold, that is, how many consecutive health
            check failures, shields the backend server.
        :value 2-5, default: 3
        :type unhealth_threshold: int

        :param health_threshold:
            Health threshold, that is, how many consecutive health checks
            are successful, then re-use the back-end server
        :value:2-5, default: 3
        :type health_threshold: int

        :param health_check_normal_status:
            The HTTP status code when the health check is normal supports
            a combination of five types of status codes,
            such as "http_1xx|http_2xx", Effective when the health check
            protocol is "HTTP"
        :value default: http_2xx|http_3xx
        :type health_check_normal_status: string

        :param server_timeout:
            Backend server maximum timeout (unit: second)
        :value 1-3600, default: 30
        :type server_timeout: int

        :param cert_ids:
            The SSL certificate to be loaded by the listener.
            Currently HTTPS listeners can only bind one SSL certificate.
        :type cert_ids:List<String>

        :param ie6_compatible:
            Is it compatible with IE6 HTTPS request
            (the protocol format is earlier SSL3.0, the security is poor)
        :value true or false, default: true
        :type ie6_compatible: bool

        :param client_token:
            If the clientToken is not specified by the user,
            a random String generated by default algorithm will be used.
        :type client_token: string

        :param config:
        :type config: baidubce.BceClientConfiguration

        :return:
        :rtype baidubce.bce_response.BceResponse
        """
        path = '/blb/%s/HTTPSlistener' % blb_id
        params = {}
        params['listenerPort'] = listener_port
        if client_token is None:
            params['clientToken'] = generate_client_token()
        else:
            params['clientToken'] = client_token
        body = {}
        if backend_port is not None:
            body['backendPort'] = backend_port
        if scheduler is not None:
            body['scheduler'] = scheduler
        if keep_session is not None:
            body['keepSession'] = keep_session
        if keep_session_type is not None:
            body['keepSessionType'] = keep_session_type
        if keep_session_duration is not None:
            body['keepSessionDuration'] = keep_session_duration
        if keep_session_cookie_name is not None:
            body['keepSessionCookieName'] = keep_session_cookie_name
        if x_forward_for is not None:
            body['xForwardFor'] = x_forward_for
        if health_check_type is not None:
            body['healthCheckType'] = health_check_type
        if health_check_port is not None:
            body['healthCheckPort'] = health_check_port
        if health_check_uri is not None:
            body['healthCheckURI'] = health_check_uri
        if health_check_timeout_in_second is not None:
            body['healthCheckTimeoutInSecond'] = \
                health_check_timeout_in_second
        if health_check_interval is not None:
            body['healthCheckInterval'] = health_check_interval
        if unhealth_threshold is not None:
            body['unhealthyThreshold'] = unhealth_threshold
        if health_threshold is not None:
            body['healthyThreshold'] = health_threshold
        if health_check_normal_status is not None:
            body['healthCheckNormalStatus'] = health_check_normal_status
        if server_timeout is not None:
            body['serverTimeout'] = server_timeout
        if cert_ids is not None:
            body['certIds'] = cert_ids
        if ie6_compatible is not None:
            body['ie6Compatible'] = ie6_compatible
        return self._send_request(http_methods.PUT, path,
                                  body=json.dumps(body), params=params,
                                  config=config)

    @required(blb_id=(str, unicode),
              portList=list)
    def delete_listeners(self, blb_id, portList, client_token=None, config=None):
        """
        Release the listener under the specified LoadBalancer,
        the listener is specified by listening to the port.

        :param blb_id:
            id of LoadBalancer to describe
        :type blb_id:string

        :param portList:
            The ports of listeners to be released
        :type portList:list<int>

        :param client_token:
            If the clientToken is not specified by the user, a random String
            generated by default algorithm will be used.
        :type client_token: string

        :param config:
        :type config: baidubce.BceClientConfiguration

        :return:
        :rtype baidubce.bce_response.BceResponse
        """
        path = '/blb/%s/listener' % blb_id
        params = {}

        params['batchdelete'] = None

        if client_token is None:
            params['clientToken'] = generate_client_token()
        else:
            params['clientToken'] = client_token

        body = {}
        body['portList'] = portList

        return self._send_request(http_methods.PUT, path,
                                  body=json.dumps(body), params=params,
                                  config=config)

    """
        BackendServer API
    """

    @required(blb_id=(str, unicode),
              backend_server_list=list)
    def add_backend_servers(self, blb_id, backend_server_list,
                            client_token=None, config=None):
        """
        Add a backend server for the specified LoadBalancer,
        support batch add

        :param blb_id:
                id of LoadBalancer to describe
        :type blb_id:string

        :param backend_server_list
                List of backend servers to be added
        :type backend_server_list:List<BackendServerModel>
        BackendServerModel{:param:instanceId
                               id of  Backend server
                           :type instanceId:string

                           :param weight
                               Backend server weight, value range [0, 100],
                               weight 0 means not to forward traffic to
                               the backend server
                           :type weight:int
                          }

        :param client_token:
            If the clientToken is not specified by the user, a random String
            generated by default algorithm will be used.
        :type client_token: string

        :param config:
        :type config: baidubce.BceClientConfiguration

        :return:
        :rtype baidubce.bce_response.BceResponse
        """
        path = '/blb/%s/backendserver' % blb_id
        params = {}

        if client_token is None:
            params['clientToken'] = generate_client_token()
        else:
            params['clientToken'] = client_token

        body = {}

        body['backendServerList'] = backend_server_list

        return self._send_request(http_methods.POST, path,
                                  body=json.dumps(body), params=params,
                                  config=config)

    @required(blb_id=(str, unicode),
              listener_port=int)
    def describe_health_status(self, blb_id, listener_port,
                               marker=None, max_keys=None, config=None):
        """
        Query the information about the backend server under the specified
        LoadBalancer identified by listenPort

        :param blb_id:
            id of LoadBalancer to describe
        :type blb_id: string

        :param listener_port:
            port to be linstened owned by listener
        :value 1-65535
        :type listener_port: int

        :param marker:
            The optional parameter marker specified in the original request
            to specify where in the results to begin listing.
            Together with the marker, specifies the list result which listing
            should begin. If the marker is not specified, the list result will
            listing from the first one.
        :type marker: string

        :param max_keys:
            The optional parameter to specifies the max number of list
            result to return.
            The default value is 1000.
        :type max_keys: int

        :param config:
        :type config: baidubce.BceClientConfiguration

        :return:
        :rtype baidubce.bce_response.BceResponse
        """
        path = '/blb/%s/backendserver' % blb_id
        params = {}

        params['listenerPort'] = listener_port

        if marker is not None:
            params['marker'] = marker
        if max_keys is not None:
            params['maxKeys'] = max_keys

        return self._send_request(http_methods.GET, path, params=params,
                                  config=config)

    @required(blb_id=(str, unicode))
    def describe_backend_servers(self, blb_id, marker=None,
                                 max_keys=None, config=None):
        """
        Query the list of backend servers under the specified LoadBalancer

        :param blb_id:
            Id of LoadBalancer to describe
        :type blb_id:string

        :param marker:
            The optional parameter marker specified in the original
            request to specify where in the results to begin listing.
            Together with the marker, specifies the list result which
            listing should begin. If the marker is not specified,
            the list result will listing from the first one.
        :type marker: string

        :param max_keys:
            The optional parameter to specifies the max number of
            list result to return.
            The default value is 1000.
        :type max_keys: int

        :param config:
        :type config: baidubce.BceClientConfiguration

        :return:
        :rtype baidubce.bce_response.BceResponse
        """
        path = '/blb/%s/backendserver' % blb_id
        params = {}

        if marker is not None:
            params['marker'] = marker
        if max_keys is not None:
            params['maxKeys'] = max_keys

        return self._send_request(http_methods.GET, path, params=params,
                                  config=config)

    @required(blb_id=(str, unicode),
              backend_server_list=list)
    def update_backend_servers(self, blb_id, backend_server_list,
                               client_token=None, config=None):
        """
        update the information about the backend server under
        the specified LoadBalancer

        :param blb_id:
            id of LoadBalancer to describe
        :type blb_id:string

        :param backend_server_list:
            List of backend servers to be updated
        :type backend_server_list:List<BackendServerModel>
        BackendServerModel{:param:instanceId
                              id of  Backend server
                           :type instanceId:string

                           :param weight
                               Backend server weight, value range [0, 100],
                               weight 0 means not to forward traffic to
                               the backend server
                           :type weight:int
                          }

        :param client_token:
            If the clientToken is not specified by the user, a random String
            generated by default algorithm will be used.
        :type client_token: string

        :param config:
        :type config: baidubce.BceClientConfiguration

        :return:
        :rtype baidubce.bce_response.BceResponse
        """
        path = '/blb/%s/backendserver' % blb_id
        params = {}

        params['update'] = None

        if client_token is None:
            params['clientToken'] = generate_client_token()
        else:
            params['clientToken'] = client_token

        body = {}
        body['backendServerList'] = backend_server_list

        return self._send_request(http_methods.PUT, path,
                                  body=json.dumps(body), params=params,
                                  config=config)

    @required(blb_id=(str, unicode),
              backend_server_list=list)
    def remove_backend_servers(self, blb_id, backend_server_list,
                               client_token=None, config=None):
        """
        Release the backend server under the specified LoadBalancer,
        which is specified by its backend server

        :param blb_id:
                id of LoadBalancer to describe
        :type blb_id:string

        :param backend_server_list:
                List of backend servers to be updated
        :type backend_server_list:List<string>

        :param client_token:
                If the clientToken is not specified by the user,
                a random String generated by default algorithm will be used.
        :type client_token: string

        :param config:
        :type config: baidubce.BceClientConfiguration

        :return:
        :rtype baidubce.bce_response.BceResponse
        """
        path = '/blb/%s/backendserver' % blb_id
        params = {}

        if client_token is None:
            params['clientToken'] = generate_client_token()
        else:
            params['clientToken'] = client_token

        body = {}
        body['backendServerList'] = backend_server_list

        return self._send_request(http_methods.PUT, path,
                                  body=json.dumps(body), params=params,
                                  config=config)


def generate_client_token_by_uuid():
    """
    The default method to generate the random string for client_token
    if the optional parameter client_token is not specified by the user.

    :return:
    :rtype string
    """
    return str(uuid.uuid4())


generate_client_token = generate_client_token_by_uuid
